[
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "21583c17-05ce-4270-8868-8b39264ed380",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC001-register_new_user",
    "description": "Test the user registration endpoint to ensure new users can register with valid email, password, and name, and receive appropriate success response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nREGISTER_ENDPOINT = \"/api/auth/register\"\nHEADERS = {'Content-Type': 'application/json'}\nTIMEOUT = 30\n\ndef test_register_new_user():\n    unique_email = f\"testuser_{uuid.uuid4()}@example.com\"\n    payload = {\n        \"email\": unique_email,\n        \"password\": \"StrongPass!123\",\n        \"name\": \"Test User\"\n    }\n    try:\n        response = requests.post(\n            BASE_URL + REGISTER_ENDPOINT,\n            json=payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 201 or response.status_code == 200, f\"Expected status code 200 or 201, got {response.status_code}\"\n        data = response.json()\n        # Usually registration returns user id or some success message\n        assert \"id\" in data or \"message\" in data or \"token\" in data, \"Response JSON missing expected keys\"\n        # Validate returned email/name if available\n        if \"user\" in data:\n            assert data[\"user\"][\"email\"] == unique_email\n            assert data[\"user\"][\"name\"] == \"Test User\"\n        if \"email\" in data:\n            assert data[\"email\"] == unique_email\n    except requests.RequestException as e:\n        assert False, f\"HTTP request to register failed: {e}\"\n\ntest_register_new_user()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 23, in test_register_new_user\nAssertionError: Expected status code 200 or 201, got 503\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.352Z",
    "modified": "2026-01-21T12:06:03.251Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "202d6d5f-f5cd-42f7-821a-53975b6a6f5c",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC002-login_user_and_receive_jwt",
    "description": "Test the login endpoint to verify that users can authenticate with valid credentials and receive a JWT token for session management.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_login_user_and_receive_jwt():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    # Use valid test credentials - these must exist in the system for this test to succeed\n    payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(login_url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        json_response = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # The response should contain a JWT token string, conventionally in a field named 'token' or 'accessToken'\n    token = json_response.get(\"token\") or json_response.get(\"accessToken\")\n    assert token is not None, \"JWT token not found in response\"\n    assert isinstance(token, str) and len(token) > 0, \"JWT token is empty or not a string\"\n\ntest_login_user_and_receive_jwt()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 34, in <module>\n  File \"<string>\", line 22, in test_login_user_and_receive_jwt\nAssertionError: Expected status code 200, got 503\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.358Z",
    "modified": "2026-01-21T12:06:03.230Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "a4597aaf-e6e2-41ea-bb23-f8d0d35f5d8f",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC003-get_current_user_profile",
    "description": "Test retrieval of the authenticated user's profile to ensure correct user data is returned when a valid JWT token is provided.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nREGISTER_URL = f\"{BASE_URL}/api/auth/register\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nPROFILE_URL = f\"{BASE_URL}/api/auth/me\"\nTIMEOUT = 30\n\ndef test_get_current_user_profile():\n    # Test user details for registration/login\n    user_data = {\n        \"email\": \"testuser_tc003@example.com\",\n        \"password\": \"StrongPass!123\",\n        \"name\": \"Test User TC003\"\n    }\n\n    token = None\n    headers = None\n\n    try:\n        # Register the user (ignore if user already exists)\n        try:\n            reg_resp = requests.post(REGISTER_URL, json=user_data, timeout=TIMEOUT)\n            # 201 Created expected or 409 Conflict if already exists\n            assert reg_resp.status_code in (201, 409)\n        except requests.RequestException as e:\n            raise AssertionError(f\"User registration request failed: {e}\")\n\n        # Login the user to get JWT token\n        try:\n            login_resp = requests.post(LOGIN_URL, json={\"email\": user_data[\"email\"], \"password\": user_data[\"password\"]}, timeout=TIMEOUT)\n            assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n            login_json = login_resp.json()\n            token = login_json.get(\"token\")\n            assert token and isinstance(token, str), \"JWT token missing or invalid in login response\"\n        except requests.RequestException as e:\n            raise AssertionError(f\"User login request failed: {e}\")\n\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Get current user profile with token\n        try:\n            profile_resp = requests.get(PROFILE_URL, headers=headers, timeout=TIMEOUT)\n            assert profile_resp.status_code == 200, f\"Profile retrieval failed with status {profile_resp.status_code}\"\n            profile_json = profile_resp.json()\n            # Validate expected fields in the user profile response\n            assert isinstance(profile_json, dict), \"Profile response is not a JSON object\"\n            assert \"email\" in profile_json and profile_json[\"email\"] == user_data[\"email\"], \"Email in profile does not match\"\n            assert \"name\" in profile_json and profile_json[\"name\"] == user_data[\"name\"], \"Name in profile does not match\"\n            assert \"id\" in profile_json, \"User profile missing 'id' field\"\n        except requests.RequestException as e:\n            raise AssertionError(f\"Profile retrieval request failed: {e}\")\n\n    finally:\n        # Cleanup: delete user if API for deletion existed (not specified in PRD, so skipping)\n        # Leaving this block for potential future cleanup steps.\n        pass\n\ntest_get_current_user_profile()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 59, in <module>\n  File \"<string>\", line 25, in test_get_current_user_profile\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.363Z",
    "modified": "2026-01-21T12:06:07.883Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "0c21f28b-94ad-470b-af62-edad2feb4178",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC004-update_current_user_profile",
    "description": "Test updating the authenticated user's profile information such as name and email, verifying that changes are saved and reflected correctly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef update_current_user_profile():\n    # Setup: Register and login a new user to get JWT token\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    profile_url = f\"{BASE_URL}/api/auth/me\"\n    password = \"TestPass123!\"\n    unique_suffix = str(uuid.uuid4()).replace(\"-\", \"\")[:8]\n    user_email = f\"testuser_{unique_suffix}@example.com\"\n    user_name = f\"Test User {unique_suffix}\"\n    new_name = f\"Updated User {unique_suffix}\"\n    new_email = f\"updated_{unique_suffix}@example.com\"\n\n    # Register user\n    register_payload = {\n        \"email\": user_email,\n        \"password\": password,\n        \"name\": user_name\n    }\n    r = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n    assert r.status_code == 201 or r.status_code == 200, f\"Unexpected status code on register: {r.status_code}\"\n\n    try:\n        # Login user\n        login_payload = {\n            \"email\": user_email,\n            \"password\": password\n        }\n        r = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Unexpected status code on login: {r.status_code}\"\n        token = r.json().get(\"token\") or r.json().get(\"access_token\")\n        assert token, \"JWT token not found in login response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Update profile (name and email)\n        update_payload = {\n            \"name\": new_name,\n            \"email\": new_email\n        }\n        r = requests.put(profile_url, json=update_payload, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Unexpected status code on profile update: {r.status_code}\"\n        updated_profile = r.json()\n        assert updated_profile.get(\"name\") == new_name, \"Name was not updated correctly\"\n        assert updated_profile.get(\"email\") == new_email, \"Email was not updated correctly\"\n\n        # Verify update by retrieving the profile again\n        r = requests.get(profile_url, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Unexpected status code on profile get: {r.status_code}\"\n        profile = r.json()\n        assert profile.get(\"name\") == new_name, \"Name in profile get does not match updated name\"\n        assert profile.get(\"email\") == new_email, \"Email in profile get does not match updated email\"\n    finally:\n        # Cleanup: No explicit delete user endpoint from PRD, so skipping user deletion.\n        # If such an endpoint existed, would use it here.\n        pass\n\nupdate_current_user_profile()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 66, in <module>\n  File \"<string>\", line 26, in update_current_user_profile\nAssertionError: Unexpected status code on register: 503\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.368Z",
    "modified": "2026-01-21T12:06:03.249Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "93adf467-0bdc-45a8-831b-4a2b48d65fb4",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC005-get_all_water_quality_readings",
    "description": "Test retrieval of all water quality readings with optional filters like location and date range, ensuring correct data and pagination.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_get_all_water_quality_readings():\n    \"\"\"\n    Test retrieval of all water quality readings with optional filters like location and date range,\n    ensuring correct data and pagination.\n    \"\"\"\n\n    # Optional filters to test\n    # 1. No filters - retrieve first page default\n    url = f\"{BASE_URL}/api/water-quality\"\n    try:\n        resp = requests.get(url, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert isinstance(data, dict), \"Response should be a JSON object\"\n        assert \"readings\" in data or \"items\" in data, \"Response missing readings/items key\"\n        # Pagination keys usually like page, total_pages etc can be checked if exist\n        # We'll allow either to cater for unknown pagination style\n        assert any(k in data for k in [\"page\", \"current_page\", \"total_pages\", \"total\", \"limit\", \"offset\"]), \"Pagination metadata missing\"\n\n        # Validate readings content if present\n        readings = data.get(\"readings\") or data.get(\"items\") or []\n        assert isinstance(readings, list), \"Readings should be a list\"\n        for reading in readings:\n            # A minimal check for expected fields\n            assert isinstance(reading, dict)\n            # Example fields: id, location, datetime, parameters, risk_level\n            # We don't have exact schema for reading fields from PRD so check some plausible keys\n            assert \"id\" in reading\n            assert \"location\" in reading or \"locationId\" in reading\n            assert \"datetime\" in reading or \"timestamp\" in reading\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # 2. Filter by location (need a valid location id, so try to get one from /api/locations first)\n    locations_url = f\"{BASE_URL}/api/locations\"\n    try:\n        loc_resp = requests.get(locations_url, timeout=TIMEOUT)\n        loc_resp.raise_for_status()\n        locations_data = loc_resp.json()\n        locations = locations_data.get(\"locations\") or locations_data.get(\"items\") or []\n        if locations:\n            location_id = None\n            first_loc = locations[0]\n            # location could have id or _id field\n            location_id = first_loc.get(\"id\") or first_loc.get(\"_id\")\n            if location_id:\n                params = {\"location\": location_id}\n                resp = requests.get(url, params=params, timeout=TIMEOUT)\n                resp.raise_for_status()\n                data = resp.json()\n                assert \"readings\" in data or \"items\" in data\n                readings = data.get(\"readings\") or data.get(\"items\") or []\n                for reading in readings:\n                    # Confirm readings belong to the location filter\n                    loc_in_reading = reading.get(\"location\") or reading.get(\"locationId\")\n                    assert loc_in_reading == location_id, \"Reading location does not match filter\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed during location filtered call: {e}\"\n\n    # 3. Filter by date range (use ISO 8601 format)\n    # Define last 7 days range\n    end_date = datetime.datetime.utcnow().date()\n    start_date = end_date - datetime.timedelta(days=7)\n    params = {\n        \"startDate\": start_date.isoformat(),\n        \"endDate\": end_date.isoformat()\n    }\n    try:\n        resp = requests.get(url, params=params, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        readings = data.get(\"readings\") or data.get(\"items\") or []\n        for reading in readings:\n            dt_str = reading.get(\"datetime\") or reading.get(\"timestamp\")\n            assert dt_str, \"Reading missing datetime/timestamp\"\n            # Parse date portion only for comparison (assuming ISO 8601)\n            dt = datetime.datetime.fromisoformat(dt_str.replace(\"Z\", \"+00:00\")).date()\n            assert start_date <= dt <= end_date, f\"Reading datetime {dt} out of filter range\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed during date range filtered call: {e}\"\n\n    # 4. Pagination test with page and limit parameters if supported\n    params = {\"page\": 1, \"limit\": 5}\n    try:\n        resp = requests.get(url, params=params, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        readings = data.get(\"readings\") or data.get(\"items\") or []\n        assert len(readings) <= 5, \"Pagination limit exceeded\"\n        # Check pagination metadata present and correct\n        pagination_keys = [\"page\", \"current_page\", \"limit\", \"total\", \"total_pages\"]\n        assert any(k in data for k in pagination_keys), \"Pagination metadata missing\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed during pagination test: {e}\"\n\n\ntest_get_all_water_quality_readings()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 18, in test_get_all_water_quality_readings\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/water-quality\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 103, in <module>\n  File \"<string>\", line 38, in test_get_all_water_quality_readings\nAssertionError: Request failed: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/water-quality\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.373Z",
    "modified": "2026-01-21T12:06:03.252Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "c1d30e88-21cd-4974-b0ea-c73e2e85510a",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC006-get_available_water_quality_parameters",
    "description": "Test the endpoint that lists all monitored water quality parameters to verify completeness and correctness of the parameter list.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n\ndef test_get_available_water_quality_parameters():\n    url = f\"{BASE_URL}/api/water-quality/parameters\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate response structure and contents\n    assert isinstance(data, list), \"Response should be a list of parameters\"\n    assert len(data) > 0, \"Parameter list should not be empty\"\n\n    # Check each parameter item is a string (assuming parameters are simple names)\n    for param in data:\n        assert isinstance(param, str), f\"Parameter should be string, got {type(param)}\"\n\n\ntest_get_available_water_quality_parameters()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 15, in test_get_available_water_quality_parameters\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/water-quality/parameters\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 33, in <module>\n  File \"<string>\", line 17, in test_get_available_water_quality_parameters\nAssertionError: Request failed: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/water-quality/parameters\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.378Z",
    "modified": "2026-01-21T12:06:02.086Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "ca9bac5a-0ac7-4a1c-9954-f75513f38b17",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC007-get_water_quality_statistics",
    "description": "Test retrieval of aggregated water quality statistics such as risk distribution to ensure accurate statistical data is returned.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_get_water_quality_statistics():\n    url = f\"{BASE_URL}/api/water-quality/stats\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate that the response contains expected keys and types\n    # Typical aggregated statistics might include risk distribution by levels: Safe, Medium, High, Critical\n    expected_keys = [\"riskDistribution\", \"totalReadings\", \"averageValues\"]\n    for key in expected_keys:\n        assert key in data, f\"Missing expected key in response: {key}\"\n\n    # Validate riskDistribution is a dict with expected risk levels as string keys and numeric counts\n    risk_distribution = data.get(\"riskDistribution\")\n    assert isinstance(risk_distribution, dict), \"riskDistribution should be a dictionary\"\n\n    expected_risk_levels = {\"Safe\", \"Medium\", \"High\", \"Critical\"}\n    assert expected_risk_levels <= set(risk_distribution.keys()), \"riskDistribution missing some risk levels\"\n\n    for level in expected_risk_levels:\n        count = risk_distribution.get(level)\n        assert isinstance(count, (int, float)) and count >= 0, f\"Invalid count for risk level {level}\"\n\n    # Validate totalReadings is a positive integer\n    total_readings = data.get(\"totalReadings\")\n    assert isinstance(total_readings, int) and total_readings >= 0, \"totalReadings should be a non-negative integer\"\n\n    # Validate averageValues contains numeric values (example: pH, DO, etc.)\n    average_values = data.get(\"averageValues\")\n    assert isinstance(average_values, dict), \"averageValues should be a dictionary\"\n    for param, value in average_values.items():\n        assert isinstance(param, str), \"Parameter name in averageValues should be string\"\n        assert isinstance(value, (int, float)), f\"Average value for {param} should be numeric\"\n\ntest_get_water_quality_statistics()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 13, in test_get_water_quality_statistics\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/water-quality/stats\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 50, in <module>\n  File \"<string>\", line 15, in test_get_water_quality_statistics\nAssertionError: Request failed: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/water-quality/stats\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.384Z",
    "modified": "2026-01-21T12:06:06.726Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "8a541e2f-0009-4137-a4bd-bc6818abed57",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC008-get_monitoring_locations_list",
    "description": "Test retrieval of all monitoring locations with filtering options, verifying correct location data and pagination.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nLOCATIONS_ENDPOINT = f\"{BASE_URL}/api/locations\"\nTIMEOUT = 30\n\ndef test_get_monitoring_locations_list():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    # Test retrieval without filters\n    try:\n        response = requests.get(LOCATIONS_ENDPOINT, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to get monitoring locations failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    # Validate response structure and pagination\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Basic checks on expected keys\n    assert \"locations\" in data, \"Response JSON does not contain 'locations' key\"\n    assert isinstance(data[\"locations\"], list), \"'locations' should be a list\"\n    # pagination keys might be present such as total, page, per_page\n    # Check at least one key to confirm pagination presence\n    pagination_keys = {\"total\", \"page\", \"per_page\"}\n    assert any(key in data for key in pagination_keys), \"Pagination info keys not found in response\"\n\n    # If there is at least one location, verify that essential fields are present\n    if data[\"locations\"]:\n        loc = data[\"locations\"][0]\n        # Expected fields, for example: id, name, state, district, coordinates\n        expected_fields = {\"id\", \"name\", \"state\", \"district\", \"coordinates\"}\n        missing_fields = expected_fields - loc.keys()\n        assert not missing_fields, f\"Missing fields in location data: {missing_fields}\"\n\n    # Test retrieval with filters: for example, state filter\n    params = {\n        \"state\": \"Maharashtra\",\n        \"page\": 1,\n        \"per_page\": 5\n    }\n    try:\n        filtered_response = requests.get(LOCATIONS_ENDPOINT, headers=headers, params=params, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to get filtered monitoring locations failed: {e}\"\n\n    assert filtered_response.status_code == 200, f\"Expected status code 200 for filtered request, got {filtered_response.status_code}\"\n\n    try:\n        filtered_data = filtered_response.json()\n    except ValueError:\n        assert False, \"Filtered response is not valid JSON\"\n\n    # Validate filtered response structure\n    assert \"locations\" in filtered_data, \"Filtered response JSON does not contain 'locations' key\"\n    assert isinstance(filtered_data[\"locations\"], list), \"'locations' in filtered response should be a list\"\n\n    # If locations returned, check that each location's state matches the filter\n    for location in filtered_data[\"locations\"]:\n        assert \"state\" in location, \"Location missing 'state' field\"\n        assert location[\"state\"].lower() == \"maharashtra\".lower(), f\"Location state {location['state']} does not match filter 'Maharashtra'\"\n\ntest_get_monitoring_locations_list()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 69, in <module>\n  File \"<string>\", line 18, in test_get_monitoring_locations_list\nAssertionError: Expected status code 200, got 503\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.389Z",
    "modified": "2026-01-21T12:06:06.734Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "05390286-3c40-4b2f-9b1f-fe27ea86bfd9",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC009-get_all_alerts_with_filters",
    "description": "Test retrieval of alerts with filtering options to ensure the system returns correct alert data including active, resolved, and dismissed alerts.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n\ndef test_get_all_alerts_with_filters():\n    url = f\"{BASE_URL}/api/alerts\"\n\n    # Test without filters (get all alerts)\n    try:\n        response = requests.get(url, timeout=TIMEOUT)\n        response.raise_for_status()\n        alerts = response.json()\n        assert isinstance(alerts, list), \"Response should be a list\"\n    except Exception as e:\n        assert False, f\"Failed to get all alerts without filters: {e}\"\n\n    # Test filter for active alerts only\n    try:\n        params = {\"status\": \"active\"}\n        response = requests.get(url, params=params, timeout=TIMEOUT)\n        response.raise_for_status()\n        active_alerts = response.json()\n        assert isinstance(active_alerts, list), \"Active alerts response should be a list\"\n        # Assert all alerts have status active if status field exists\n        for alert in active_alerts:\n            assert alert.get(\"status\") == \"active\"\n    except Exception as e:\n        assert False, f\"Failed to get active alerts: {e}\"\n\n    # Test filter for resolved alerts only\n    try:\n        params = {\"status\": \"resolved\"}\n        response = requests.get(url, params=params, timeout=TIMEOUT)\n        response.raise_for_status()\n        resolved_alerts = response.json()\n        assert isinstance(resolved_alerts, list), \"Resolved alerts response should be a list\"\n        for alert in resolved_alerts:\n            assert alert.get(\"status\") == \"resolved\"\n    except Exception as e:\n        assert False, f\"Failed to get resolved alerts: {e}\"\n\n    # Test filter for dismissed alerts only\n    try:\n        params = {\"status\": \"dismissed\"}\n        response = requests.get(url, params=params, timeout=TIMEOUT)\n        response.raise_for_status()\n        dismissed_alerts = response.json()\n        assert isinstance(dismissed_alerts, list), \"Dismissed alerts response should be a list\"\n        for alert in dismissed_alerts:\n            assert alert.get(\"status\") == \"dismissed\"\n    except Exception as e:\n        assert False, f\"Failed to get dismissed alerts: {e}\"\n\n\ntest_get_all_alerts_with_filters()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 13, in test_get_all_alerts_with_filters\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/alerts\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 17, in test_get_all_alerts_with_filters\nAssertionError: Failed to get all alerts without filters: 503 Server Error: Service Unavailable for url: http://localhost:5000/api/alerts\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.396Z",
    "modified": "2026-01-21T12:06:08.086Z"
  },
  {
    "projectId": "feb78b74-51cd-4755-a4c2-3b8f557319ba",
    "testId": "7da24562-5f2c-4b2c-b5d1-62018b48d9ef",
    "userId": "140874d8-f091-7062-1daf-5752d73d7401",
    "title": "TC010-resolve_alert_by_id",
    "description": "Test the alert resolution endpoint to verify that an alert can be marked as resolved with optional notes and the status updates accordingly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_resolve_alert_by_id():\n    # Authenticate user to get JWT token (assuming test user exists)\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    login_resp = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, \"Login failed\"\n    token = login_resp.json().get(\"token\")\n    assert token, \"No JWT token received\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Create a new alert to resolve (if no alert id provided, create one)\n    # Since API does not specify alert creation endpoint in PRD, we'll check for active alerts then pick one or fail if none.\n    # If create alert endpoint existed, we would create then delete it. Here, fallback to picking an active alert.\n    active_alerts_url = f\"{BASE_URL}/api/alerts/active\"\n    active_alerts_resp = requests.get(active_alerts_url, headers=headers, timeout=TIMEOUT)\n    assert active_alerts_resp.status_code == 200, \"Failed to retrieve active alerts\"\n    active_alerts = active_alerts_resp.json()\n    assert isinstance(active_alerts, list), \"Active alerts response is not a list\"\n    assert len(active_alerts) > 0, \"No active alerts to resolve for test\"\n\n    alert = active_alerts[0]\n    alert_id = alert.get(\"id\")\n    assert alert_id, \"Alert has no ID\"\n\n    resolve_url = f\"{BASE_URL}/api/alerts/{alert_id}/resolve\"\n    resolve_payload = {\n        \"notes\": \"Resolved during automated test\"\n    }\n\n    # Resolve alert\n    resolve_resp = requests.put(resolve_url, headers=headers, json=resolve_payload, timeout=TIMEOUT)\n    assert resolve_resp.status_code == 200, f\"Failed to resolve alert {alert_id}\"\n\n    resolved_alert = resolve_resp.json()\n    # Validate updated status and notes\n    assert resolved_alert.get(\"id\") == alert_id, \"Resolved alert ID mismatch\"\n    assert resolved_alert.get(\"status\") == \"resolved\", \"Alert status was not updated to resolved\"\n    assert \"notes\" in resolved_alert and \"Resolved during automated test\" in resolved_alert[\"notes\"], \"Notes not updated correctly\"\n\n    # Cleanup: Optionally, could try to revert alert status if needed, but PRD doesn't define this.\n    # So no cleanup code is added here.\n\ntest_resolve_alert_by_id()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 55, in <module>\n  File \"<string>\", line 14, in test_resolve_alert_by_id\nAssertionError: Login failed\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-21T12:05:34.401Z",
    "modified": "2026-01-21T12:06:09.159Z"
  }
]
